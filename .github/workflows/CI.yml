name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:

  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - uses: msalib/py-geo-rasterize/./.github/workflows/build.yml@main
        with:
          ref: ${{ env.GITHUB_REF_NAME }}


  # release:
  #   name: Release
  #   runs-on: ubuntu-latest
  #   if: github.ref == 'refs/heads/main' && github.event_name == 'push'
  #   needs: [ linux, windows, macos ]
  #   steps:
  #     - uses: actions/download-artifact@v2
  #       with:
  #         name: wheels
  #     - name: Publish to PyPI
  #       uses: messense/maturin-action@v1
  #       env:
  #         MATURIN_PYPI_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
  #       with:
  #         command: upload
  #         args: --repository-url=https://test.pypi.org/legacy/ --username=msalib --skip-existing *



# put release in a separate file consisting of a python-semantic-release version job that outputs a ref followed by parallel build jobs for each platform followed by the upload job

# encapsulate build flow into its own file with input ref that defaults to current branch
# then we have a separate build that invokes it on push in a build job along with a release job t
